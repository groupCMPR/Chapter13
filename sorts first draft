//A > Create a dynamic array and fill with random elements
//B > Display the unsorted array
//C > Perform BubbleSort
//D > Perform SelectionSort
//E > Perform InsertionSort
//F > Perform QuickSort
//G > Perform MergeSort
//H > Perform HeapSort

#include <iostream>
#include <vector>
#include <algorithm>
#include "input.h"
using namespace std;

vector<double> sort_array = { 78.4, 59.3, 19.4, 44.1, 53.1, 52.9, 74.5, 81.8, 84.0, 21.4, 59.4, 34.3, 47.5, 79.2, 7.5, 63.5, 17.0, 20.2, 87.9, 18.6 };




int main() {

	make_heap(sort_array.begin(), sort_array.end());
    sort_heap_recurse(sort_array.size() - 1);
		for (auto iter = sort_array.begin(); iter != sort_array.end(); ++iter) {
			cout << *iter << " ";
		}

}
	//void merge_sort(size_t start, size_t end);

//ascending insertion, 1, 0
//int insertion_sort_recurse(size_t start, int count) {
//
//	if (start >= sort_array.size())
//		return count;
//
//	int next_element = sort_array[start];
//	for (int j = start - 1; j >= 0; --j) {
//		if (next_element > sort_array[j]) {
//			sort_array[j + 1] = next_element;
//			break;
//		}
//		else {
//			swap(sort_array[j + 1], sort_array[j]);
//		}
//		++count;
//	}
//
//
//	return insertion_sort_recurse(start + 1, count + 1);
//
//}


//0,0
//int bubble_sort_recurse(size_t start, int count)
//{
//	if (start >= sort_array.size())
//		return count;
//
//	//bubble sort - ascending
//	for (int i = 1; i < sort_array.size(); ++i) {
//		if (sort_array[i] < sort_array[i - 1]) {
//			swap(sort_array[i], sort_array[i - 1]);
//			++count;
//		}
//	}
//
//	return bubble_sort_recurse(start + 1, count);
//}

//0, 0
//selection sort - ascending
//int selection_sort_recurse(size_t start, int count) {
//
//	if (start >= sort_array.size())
//		return count;
//
//	double found_number = sort_array[start];
//	int position = start;
//
//	for (int i = start + 1; i < sort_array.size(); ++i) {
//		if (found_number > sort_array[i]) {
//			found_number = sort_array[i];
//			position = i;
//
//		}
//	}
//
//	swap(sort_array[start], sort_array[position]);
//
//	return selection_sort_recurse(start + 1, count + 1);
//}

// use make_heap before using this  
// size - 1, 0
// ascending - if max heap and descending if min heap 
//int sort_heap_recurse(size_t end, int count) {
//    if (end == 1) {
//        return count;
//    }
//
//    swap(sort_array[0], sort_array[end]);
//    ++count;
//    make_heap(sort_array.begin(), sort_array.begin() + end);
//    sort_heap_recurse(end - 1);
//}
