//Name: Neidy Malaga and Vivian Huynh
//Date: 11/29/2023
//Description: template file for template class SortSimulations

//----------------------------------------------------------------------
// 
//						CONSTRUCTORS
// 
//----------------------------------------------------------------------
template <class T>
SortSimulations<T>::SortSimulations()
{}

template <class T>
SortSimulations<T>::SortSimulations(SortSimulations<T>& obj)
{
	myVector = obj.myVector;
}

//----------------------------------------------------------------------
// 
//							ACCESSORS
// 
//----------------------------------------------------------------------
//Precondition : Passing in two valid template values
//Postcondition: Return the less than value, ascending order
template <class T>
bool lesserCompare(T comp_1, T comp_2) 
{
	return (comp_1 < comp_2);
}
//Precondition : Passing in two valid template values
//Postcondition: Return the greater than value, descending order
template <class T>
bool greaterCompare(T comp_1, T comp_2) 
{
	return (comp_1 > comp_2);
}
//---------------------------------------------------------------------------------------------------- TODO
//Precondition : Passing in low > -1 and high < size
//Postcondition: Switches elements for quicksorting in descending order
template <class T>
T SortSimulations<T>::partition_descend(int low, int high) 
{
	T pivot = myVector[low];

	//switches numbers from high to low positions until it goes past subarray allotted
	while (low < high) {
		while (low < high && myVector[high] <= pivot)
			--high;

		//"swaps" elements
		myVector[low] = myVector[high];

		while (low < high && pivot <= myVector[low])
			++low;

		//"swaps" elements
		myVector[high] = myVector[low];
	}

	//settles the pivot to compare at low when called again
	myVector[low] = pivot;

	return low;
}
//---------------------------------------------------------------------------------------------------- TODO
//Precondition : Passing in low > -1 and high < size
//Postcondition: Switches elements for quicksorting in ascending order
template <class T>
T SortSimulations<T>::partition_ascend(int low, int high)
{
	T pivot = myVector[low];

	//switches numbers from high to low
	while (low < high) {
		while (low < high && myVector[high] >= pivot)
			--high;

		//"swaps" elements
		myVector[low] = myVector[high];

		while (low < high && pivot >= myVector[low])
			++low;

		//"swaps" elements
		myVector[high] = myVector[low];
	}

	//settles the pivot to compare at low when called again
	myVector[low] = pivot;

	return low;
}
//Precondition : N/A
//Postcondition: Returning the size of the dynamic array
template <class T>
int SortSimulations<T>::getSize()
{
	return myVector.size();
}
//Precondition : N/A
//Postcondition: Return TRUE if dynamic array is empty
//				 Return FALSE if dynamic array is NOT empty
template <class T>
bool SortSimulations<T>::isEmpty()
{
	return myVector.empty();
}
//Precondition : start is 0, count is 0, function for comparison(valid template data type)
//				 ascending: (0, 0, lesser_compare)
//				 descending: (0, 0, greater_compare)
//Postcondition: Does bubble sort, returns count
template <class T>
int SortSimulations<T>::bubbleSort(int start, int count, bool (compare_func)(T, T))
{
	if (start >= myVector.size())
		return count;

	// sorts all pairs once
	//them recurses to do the sort again (like a double for loop)
	for (int i = 1; i < myVector.size(); ++i) {
		if (compare_func(myVector[i], myVector[i - 1])) {
			swap(myVector[i], myVector[i - 1]);
			++count;
		}
	}

	return bubbleSort(start + 1, count, compare_func);
}
//Precondition : at start 0, count 0, function for comparison(valid template data type)
//				 ascending: (0, 0, greater_compare)
//				 descending: (0, 0, lesser_compare)
//Postcondition: Does selection sort, returns count
template <class T>
int SortSimulations<T>::selectionSort(int start, int count, bool (compare_func)(T, T)) 
{
	if (start >= myVector.size())
		return count;

	T found_number = myVector[start];
	int position = start;

    //finds position of greatest or least value and swaps to next position
	for (int i = start + 1; i < myVector.size(); ++i) {
		if (compare_func(found_number, myVector[i])) {
			found_number = myVector[i];
			position = i;

		}
	}

	swap(myVector[start], myVector[position]);

	return selectionSort(start + 1, count + 1, compare_func);
}
//Precondition : start is 1, count is 0, function for comparison(valid template data type)
//				 ascending: 1, 0, greater_compare
//				 descending: 1, 0, lesser_compare
//Postcondition: Does insert sort, returns count
template <class T>
int SortSimulations<T>::insertionSort(int start, int count, bool (compare_func)(T, T))
{
	if (start >= myVector.size())
		return count;

	//will move element to previous location if it is greater or lesser than previous item
	//if not will move previous element up one
	T next_element = myVector[start];
	for (int j = start - 1; j >= 0; --j) {
		if (compare_func(next_element, myVector[j])) {
			myVector[j + 1] = next_element;
			break;
		}
		else {
			swap(myVector[j + 1], myVector[j]);
		}
		++count;
	}

	return insertionSort(start + 1, count + 1, compare_func);
}
//Precondition : must be heap before (make_heap), end is size -1, count is 0, function for comparison(valid template data type)
//				 ascending: make_heap(sort_array.begin(), sort_array.end(), lesser_compare) 
//							heapSort(sort_array.size()-1, 0, lesser_compare)
//				 descending: make_heap(sort_array.begin(), sort_array.end(), greater_compare) 
//							 heapSort(sort_array.size()-1, 0, greater_compare)
//Postcondition: Does heap sort, returns count
template <class T>
int SortSimulations<T>::heapSort(int end, int count, bool (compare_func)(T, T)) 
{
    if (end <= 0) {
        return count;
    }

    //swaps ends
    swap(myVector[0], myVector[end]);
    ++count;

    //reheaps
    make_heap(myVector.begin(), myVector.begin() + end, compare_func);
    return heapSort(end - 1, count, compare_func);
}

//----------------------------------------------------------------------
// 
//							MUTATORS
// 
//----------------------------------------------------------------------
//Precondition : Passing in a valid template value
//Postcondition: Push in the value to the back of the dynamic array
template <class T>
void SortSimulations<T>::push(const T& element)
{
	myVector.push_back(element);
}
//Precondition : low starts at 0, high at size - 1, true if descend, false if ascend
//Postcondition: Does quick sort
template <class T>
void SortSimulations<T>::quickSort(int low, int high, bool ascendDescend) 
{
	if (low < high)
	{
		//partitions (switches elements)
		size_t partition_index;
		if (ascendDescend == false)
			partition_index = partition_descend(low, high);
		else
			partition_index = partition_ascend(low, high);

		//makes into subarrays	
		quickSort(low, partition_index - 1, ascendDescend);
		quickSort(partition_index + 1, high, ascendDescend);
	}
}
//Precondition : start is 0, mid is half of size, end is size - 1, function for comparison(valid template data type) 
//				 ascending: mergeSort(0, myVector.size() - 1, lesser_compare);
//				 descending: mergeSort(0, myVector.size() - 1, greater_compare);
//Postcondition: merges and sorts everything, (counts every instance it was in a while loop)
template <class T>
void SortSimulations<T>::mergeSortHalf(int start, int mid, int end, bool (compare_func)(T, T))
{
	vector<T> merged_array;
	merged_array.resize(myVector.size());

	size_t first_arr_count = start, second_arr_count = mid + 1, temp_count = start;

    //if subarrays are not at end
    //gets max or min value
    while (first_arr_count <= mid && second_arr_count <= end) {
        if (compare_func(myVector[first_arr_count], myVector[second_arr_count])) {
            merged_array[temp_count++] = myVector[first_arr_count++];
        }
        else {
            merged_array[temp_count++] = myVector[second_arr_count++];
        }
    }

    //if there is any left from first, place inside new array
    while (first_arr_count <= mid) {
        merged_array[temp_count++] = myVector[first_arr_count++];
    }

    //if there is any left from second subarray, place inside new array
    while (second_arr_count <= end) {
        merged_array[temp_count++] = myVector[second_arr_count++];

    }

    //put inside first array
    for (start; start <= end; ++start) {
        myVector[start] = merged_array[start];
    }
}
//Precondition : start is 0, mid is half, end is size - 1, function for comparison(valid template data type) 
//				 ascending: mergeSort(0, myVector.size() - 1, lesser_compare);
//				 descending: mergeSort(0, myVector.size() - 1, greater_compare);
//Postcondition: splits into pairs of array
template <class T>
void SortSimulations<T>::mergeSort(int start, int end, bool (compare_func)(T, T))
{
	//takes a portion, as array in pairs
    if (start < end) {
        size_t mid = (end + start) / 2;
        mergeSort(start, mid, compare_func);
        mergeSort(mid + 1, end, compare_func);
        mergeSortHalf(start, mid, end, compare_func);
    }
}
//Precondition : Dynamic array is not empty
//Postcondition: Display all the values in the dynamic array
template <class T>
void SortSimulations<T>::display()
{
	for (int i = 0; i < myVector.size(); i++)
	{
		cout << fixed << setprecision(1) << myVector[i];
		if (myVector.size() != 1 && i < myVector.size() - 1)
		{
			cout << ", ";
		}
	}
	cout << '\n';
}
